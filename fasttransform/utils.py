# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/00_utils.ipynb.

# %% auto 0
__all__ = ['get_name', 'is_tuple', 'retain_meta', 'default_set_meta', 'cast', 'retain_type']

# %% ../nbs/00_utils.ipynb 1
from typing import Any

from plum import dispatch
from numpy import ndarray

from fastcore.imports import *
from fastcore.foundation import *
from fastcore.utils import *

# %% ../nbs/00_utils.ipynb 5
def get_name(o):
    if hasattr(o,'__qualname__'): return o.__qualname__
    if hasattr(o,'__name__'): return o.__name__
    return o.__class__.__name__

# %% ../nbs/00_utils.ipynb 6
def is_tuple(o): return isinstance(o, tuple) and not hasattr(o, '_fields')

# %% ../nbs/00_utils.ipynb 9
def retain_meta(x, res, as_copy=False):
    "Call `res.set_meta(x)`, if it exists"
    if hasattr(res,'set_meta'): res.set_meta(x, as_copy=as_copy)
    return res
     

# %% ../nbs/00_utils.ipynb 10
def default_set_meta(self, x, as_copy=False):
    "Copy over `_meta` from `x` to `res`, if it's missing"
    if hasattr(x, '_meta') and not hasattr(self, '_meta'):
        meta = x._meta
        if as_copy: meta = copy(meta)
        self._meta = meta
    return self
     

# %% ../nbs/00_utils.ipynb 11
@dispatch
def cast(x, typ):
    "cast `x` to type `typ` (may also change `x` inplace)"
    res = typ._before_cast(x) if hasattr(typ, '_before_cast') else x
    if risinstance('ndarray', res): res = res.view(typ)
    elif hasattr(res, 'as_subclass'): res = res.as_subclass(typ)
    else:
        try: res.__class__ = typ
        except: res = typ(res)
    return retain_meta(x, res)

# %% ../nbs/00_utils.ipynb 18
def retain_type(new, old, ret_type,as_copy=False):
    if new is None: return new
    if ret_type is NoneType: return new
    if ret_type is Any:
        if not isinstance(old, type(new)): return new
        ret_type = old if isinstance(old,type) else type(old)
    if ret_type is NoneType or isinstance(new,ret_type): return new
    return retain_meta(old, cast(new, ret_type), as_copy=as_copy)   
