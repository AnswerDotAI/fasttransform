"""Definition of `Transform` and `Pipeline`"""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/01_transform.ipynb.

# %% auto 0
__all__ = ['Transform']

# %% ../nbs/01_transform.ipynb 1
from typing import Any

from fastcore.imports import *
from fastcore.foundation import *
from fastcore.utils import *
#from fastcore.dispatch import retain_meta, cast  # move to fasttransform

from plum.function import Function
from plum import NotFoundLookupError

from .utils import _is_tuple, retain_type, retain_meta, cast, _get_name

# %% ../nbs/01_transform.ipynb 8
def _has_self_arg(f) -> bool:
    try: return f.__code__.co_varnames[0] == 'self'
    except (AttributeError, IndexError): return False

# %% ../nbs/01_transform.ipynb 9
def _subclass_decorator(cls, f):
    nm = f.__name__
    if nm not in _tfm_methods: raise RuntimeError(f"{nm} not in {_tfm_methods}")
    if not hasattr(cls, nm): setattr(cls, nm, Function(f).dispatch(f))
    else: getattr(cls,nm).dispatch(f)
    return cls

# %% ../nbs/01_transform.ipynb 10
_tfm_methods = 'encodes','decodes','setups'
def _is_tfm_method(n, f): return n in _tfm_methods and callable(f)

class _TfmDict(dict):
    def __setitem__(self, k, v):
        if not _is_tfm_method(k, v): return super().__setitem__(k,v)
        if k not in self: super().__setitem__(k,Function(v).dispatch(v))
        self[k].dispatch(v)     

# %% ../nbs/01_transform.ipynb 11
class _TfmMeta(type):
    @classmethod
    def __prepare__(cls, name, bases): 
        return _TfmDict()

# %% ../nbs/01_transform.ipynb 12
class Transform(metaclass=_TfmMeta):
    "Delegates (`__call__`,`decode`,`setup`) to (<code>encodes</code>,<code>decodes</code>,<code>setups</code>) if `split_idx` matches"
    split_idx,init_enc,order,train_setup = None,None,0,None
    
    def __init__(self,enc=None,dec=None, split_idx=None, order=None):
        self.split_idx = ifnone(split_idx, self.split_idx)
        if order is not None: self.order=order 
        if enc:=L(enc): self.encodes = Function(enc[0])
        for e in enc: self.encodes.dispatch(e)
        if dec:=L(dec): self.decodes = Function(dec[0])
        for d in dec: self.decodes.dispatch(d)

    @property
    def name(self): return getattr(self, '_name', _get_name(self))
    def __repr__(self):# return f'{self.name}:\nencodes: {self.encodes}decodes: {self.decodes}'
        enc = f"<{len(self.encodes.methods)} methods>" if hasattr(self, 'encodes') else "None"
        dec = f"<{len(self.decodes.methods)} methods>" if hasattr(self, 'decodes') else "None"
        return f'{self.name}:\nencodes: {enc}\ndecodes: {dec}'
    def __call__(self,*args,split_idx=None, **kwargs): return self._call('encodes', split_idx, *args,**kwargs)
    def decode(self, *args,split_idx=None, **kwargs): return self._call('decodes', split_idx, *args, **kwargs)
    def setup(self, items=None, train_setup=False):
        train_setup = train_setup if self.train_setup is None else self.train_setup
        setups = getattr(self,'setups',lambda o:o)
        return setups(getattr(items, 'train', items) if train_setup else items)

    def _call(self, nm, split_idx=None, *args, **kwargs):
        if split_idx!=self.split_idx and self.split_idx is not None: return args[0]
        if not hasattr(self, nm): return args[0]
        return self._do_call(nm, *args, **kwargs)

    def _do_call(self, nm, *args, **kwargs):
        x = args[0]
        if not _is_tuple(x): 
            f_args = args if type(self) is Transform else (self,)+args
            try: method, ret_type = getattr(self,nm)._resolve_method_with_cache(f_args)
            except NotFoundLookupError: return x
            return retain_type(method(*f_args,**kwargs), x, ret_type)
        res = tuple(self._do_call(nm, x_, *args[1:], **kwargs) for x_ in x)
        return retain_type(res, x, Any)

    def __init_subclass__(cls):
        orig_init = getattr(cls,'__init__',lambda o:None)
        def __init__(self,*args,**kwargs):
            orig_init(self, *args, **kwargs)
            for nm in _tfm_methods: 
                if o:=getattr(cls,nm,None): setattr(self, nm, MethodType(o, self))
        cls.__init__ = __init__

    def __new__(cls, enc=None, dec=None):
        if issubclass(cls,Transform) and _has_self_arg(enc) and dec is None: return _subclass_decorator(cls, enc)
        return super().__new__(cls)

add_docs(Transform, decode="Delegate to decodes to undo transform", setup="Delegate to setups to set up transform")
