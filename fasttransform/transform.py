"""Definition of `Transform` and `Pipeline`"""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/01_transform.ipynb.

# %% auto 0
__all__ = ['Sig', 'Transform', 'InplaceTransform', 'DisplayedTransform', 'ItemTransform', 'get_func', 'Func']

# %% ../nbs/01_transform.ipynb 1
from typing import Any

from fastcore.imports import *
from fastcore.foundation import *
from fastcore.utils import *

from plum.function import Function
from plum import NotFoundLookupError

from .utils import get_name, is_tuple, retain_type
from .monkeydispatch import monkeydispatch

# %% ../nbs/01_transform.ipynb 9
class Transform:
    "Delegates (`__call__`,`decode`,`setup`) to (<code>encodes</code>,<code>decodes</code>,<code>setups</code>) if `split_idx` matches"
    split_idx,init_enc,order,train_setup = None,None,0,None
    
    def __init__(self,enc=None,dec=None, split_idx=None, order=None):
        self.split_idx = ifnone(split_idx, self.split_idx)
        if order is not None: self.order=order 
        if enc:=L(enc): self.encodes = Function(enc[0])
        for e in enc: self.encodes.dispatch(e)
        if dec:=L(dec): self.decodes = Function(dec[0])
        for d in dec: self.decodes.dispatch(d)

    @property
    def name(self): return getattr(self, '_name', get_name(self))
    def __repr__(self):
        enc = 0 if not hasattr(self, 'encodes') else len(getattr(self.encodes,'methods', [1]))
        dec = 0 if not hasattr(self, 'encodes') else len(getattr(self.encodes,'methods', [1]))
        return f'{self.name}(enc:{enc},dec:{dec})'
    def __call__(self,*args,split_idx=None, **kwargs): return self._call('encodes', split_idx, *args,**kwargs)
    def decode(self, *args,split_idx=None, **kwargs): return self._call('decodes', split_idx, *args, **kwargs)
    def setup(self, items=None, train_setup=False):
        train_setup = train_setup if self.train_setup is None else self.train_setup
        setups = getattr(self,'setups',lambda o:o)
        return setups(getattr(items, 'train', items) if train_setup else items)

    def _call(self, nm, split_idx=None, *args, **kwargs):
        if split_idx!=self.split_idx and self.split_idx is not None: return args[0]
        if not hasattr(self, nm): return args[0]
        return self._do_call(nm, *args, **kwargs)

    def _do_call(self, nm, *args, **kwargs):
        if is_tuple(x:=args[0]): 
            res = tuple(self._do_call(nm, x_, *args[1:], **kwargs) for x_ in x)
            return retain_type(res, x, Any)
        f = getattr(self,nm)
        
        if isinstance(f,MethodType): f, f_args = f._f, (self,)+args
        else: f_args = args
        try: method, ret_type = f._resolve_method_with_cache(f_args)
        except NotFoundLookupError: return x
        return retain_type(method(*f_args,**kwargs), x, ret_type)


# %% ../nbs/01_transform.ipynb 127
class InplaceTransform(Transform):
    "A `Transform` that modifies in-place and just returns whatever it's passed"
    def _call(self, fn, split_idx=None, *args, **kwargs):
        super()._call(fn,split_idx,*args, **kwargs)
        return args[0]

# %% ../nbs/01_transform.ipynb 131
class DisplayedTransform(Transform):
    "A transform with a `__repr__` that shows its attrs"

    @property
    def name(self): return f"{super().name} -- {getattr(self,'__stored_args__',{})}\n"

# %% ../nbs/01_transform.ipynb 137
class ItemTransform(Transform):
    "A transform that always take tuples as items"
    _retain = True
    def __call__(self, x, **kwargs): return self._call1(x, '__call__', **kwargs)
    def decode(self, x, **kwargs):   return self._call1(x, 'decode', **kwargs)
    def _call1(self, x, name, **kwargs):
        if not is_tuple(x): return getattr(super(), name)(x, **kwargs)
        y = getattr(super(), name)(list(x), **kwargs)
        if not self._retain: return y
        if is_listy(y) and not isinstance(y, tuple): y = tuple(y)
        return retain_type(y, x, Any)
     

# %% ../nbs/01_transform.ipynb 146
def get_func(t, name, *args, **kwargs):
    "Get the `t.name` (potentially partial-ized with `args` and `kwargs`) or `noop` if not defined"
    f = nested_callable(t, name)
    return f if not (args or kwargs) else partial(f, *args, **kwargs)

# %% ../nbs/01_transform.ipynb 150
class Func():
    "Basic wrapper around a `name` with `args` and `kwargs` to call on a given type"
    def __init__(self, name, *args, **kwargs): self.name,self.args,self.kwargs = name,args,kwargs
    def __repr__(self): return f'sig: {self.name}({self.args}, {self.kwargs})'
    def _get(self, t): return get_func(t, self.name, *self.args, **self.kwargs)
    def __call__(self,t): return mapped(self._get, t)

# %% ../nbs/01_transform.ipynb 153
class _Sig():
    def __getattr__(self,k):
        def _inner(*args, **kwargs): return Func(k, *args, **kwargs)
        return _inner

Sig = _Sig()
     
