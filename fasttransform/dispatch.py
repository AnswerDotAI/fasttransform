"""Basic single and dual parameter dispatch"""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/04_dispatch.ipynb.

# %% ../nbs/04_dispatch.ipynb 1
from __future__ import annotations
from fastcore.imports import *
from fastcore.foundation import *
from fastcore.utils import *

from collections import defaultdict

from plum.function import Function
from plum.signature import Signature
from plum import NotFoundLookupError, AmbiguousLookupError

# %% auto 0
__all__ = ['typedispatch', 'TypeDispatch', 'FastFunction', 'FastDispatcher', 'retain_meta', 'default_set_meta', 'cast',
           'retain_type', 'retain_types', 'explode_types']

# %% ../nbs/04_dispatch.ipynb 4
# TODO(Rens): find better spot for this?
def _get_name(f):
    """Get the name of a function or callable object"""
    return getattr(f, '__name__', getattr(f.__class__, '__name__', str(f)))

# %% ../nbs/04_dispatch.ipynb 7
# TODO(Rens): Add docs
class TypeDispatch:
    "Dictionary-like object; `__getitem__` matches keys of types using `issubclass`"
    def __init__(self, funcs=(), bases=()):
        self.func = None
        self.bases = [b for b in (bases if isinstance(bases, Iterable) else (bases,)) 
                    if b is not None]  # Filter out None bases
        self.inst = None
        self.owner = None
        
        # Try to get func from bases if we don't have one
        if not funcs and self.bases:
            for base in self.bases:
                if base.func is not None:
                    self.func = base.func
                    break
        
        funcs = funcs if isinstance(funcs, Iterable) else (funcs,)
        for f in funcs: self.add(f)     

    def add(self, f):
        "Add type `t` and function `f`"
        if not self.func:
            # TODO(Rens): extract to separate func?
            # Wrap f in a function that has __name__
            if not hasattr(f, '__name__'):
                orig_f = f
                def wrapped(*args, **kwargs): return orig_f(*args, **kwargs)
                wrapped.__name__ = _get_name(f)
                f = wrapped
            self.func = Function(f)
        self.func.dispatch(f)
    
    def __call__(self, *args, **kwargs):
        # TODO(Rens): handle staticfunctions/classmethods
        if (self.inst or self.owner):
            # Add the proper instance/owner as first arg
            args = ((self.inst or self.owner),) + args
            
        # Get types for dispatch
        # Get types first, like original implementation
        # TODO(Rens): remove this!?
        ts = tuple(type(a) for a in args[:2])
        
        # Find matching function
        f = self[ts]
        if not f: return args[1] if self.inst or self.owner else args[0]
        return f(*args, **kwargs)
    
    def __getitem__(self, k):
        "Find first matching type that is a super-class of `k`"
        if not self.func: return None
        if self.func: self.func._resolve_pending_registrations()

        # If a single Signature is passed, use it directly
        if not isinstance(k,Signature):
            k = Signature(*k) if isinstance(k, Iterable) else Signature(k)
            
        try:
            return self.func._resolver.resolve(k).implementation
        except NotFoundLookupError:
            pass

        for base in self.bases:
            if (res := base[k]): return res

        return None
        
    def __get__(self, instance, owner):
        self.inst = instance
        self.owner = owner
        return self
        
    def returns(self, x):
        "Get the return type of annotation of `x`."
        return anno_ret(self[type(x)])

# %% ../nbs/04_dispatch.ipynb 74
# this works in 09 vision, but not in 03 data core
# class DispatchReg:
#     "A global registry for `TypeDispatch` objects keyed by function name"
#     def __init__(self): self.d = defaultdict(TypeDispatch)
#     def __call__(self, f):
#         if isinstance(f, (classmethod, staticmethod)): nm = f'{f.__func__.__qualname__}'
#         else: nm = f'{f.__qualname__}'
#         if isinstance(f, classmethod): f=f.__func__
#         self.d[nm].add(f)
#         return self.d[nm]

# typedispatch = DispatchReg()

# # this works in 03 data core, but not with 09 vision
# from plum.dispatcher import Dispatcher
# typedispatch = Dispatcher()

# %% ../nbs/04_dispatch.ipynb 75
from plum.dispatcher import Dispatcher, is_in_class

class FastFunction(Function):
    def __getitem__(self, k):
        self._resolve_pending_registrations()

        # If a single Signature is passed, use it directly
        if not isinstance(k,Signature):
            k = Signature(*k) if isinstance(k, Iterable) else Signature(k)

        try:
            return self._resolver.resolve(k).implementation
        except NotFoundLookupError:
            pass
        
        # TODO(Rens): this is a temporary fix for fastai 
        # which uses show_batch[object] while the function has 3 args
        # so technically show_batch[object, object, object] would be ok.
        # if k.types == (object,):
        if self.__name__ == "show_batch" and len(k.types) == 1:
            return self.__getitem__(k.types + (object, object))
            
        return None


class FastDispatcher(Dispatcher):
    def _get_function(self, method: Callable) -> FastFunction:
        # If a class is the owner, use a namespace specific for that class. Otherwise,
        # use the global namespace.
        if is_in_class(method):
            owner = get_class(method)
            if owner not in self.classes:
                self.classes[owner] = {}
            namespace = self.classes[owner]
        else:
            owner = None
            namespace = self.functions

        # Create a new function only if the function does not already exist.
        name = method.__name__
        if name not in namespace:
            namespace[name] = FastFunction(
                method,
                owner=owner,
                warn_redefinition=self.warn_redefinition,
            )

        return namespace[name]

typedispatch = FastDispatcher()

# %% ../nbs/04_dispatch.ipynb 83
_all_=['cast']

# %% ../nbs/04_dispatch.ipynb 84
def retain_meta(x, res, as_copy=False):
    "Call `res.set_meta(x)`, if it exists"
    if hasattr(res,'set_meta'): res.set_meta(x, as_copy=as_copy)
    return res

# %% ../nbs/04_dispatch.ipynb 85
def default_set_meta(self, x, as_copy=False):
    "Copy over `_meta` from `x` to `res`, if it's missing"
    if hasattr(x, '_meta') and not hasattr(self, '_meta'):
        meta = x._meta
        if as_copy: meta = copy(meta)
        self._meta = meta
    return self

# %% ../nbs/04_dispatch.ipynb 86
@typedispatch
def cast(x, typ):
    "cast `x` to type `typ` (may also change `x` inplace)"
    res = typ._before_cast(x) if hasattr(typ, '_before_cast') else x
    if risinstance('ndarray', res): res = res.view(typ)
    elif hasattr(res, 'as_subclass'): res = res.as_subclass(typ)
    else:
        try: res.__class__ = typ
        except: res = typ(res)
    return retain_meta(x, res)

# %% ../nbs/04_dispatch.ipynb 92
def retain_type(new, old=None, typ=None, as_copy=False):
    "Cast `new` to type of `old` or `typ` if it's a superclass"
    # e.g. old is TensorImage, new is Tensor - if not subclass then do nothing
    if new is None: return
    assert old is not None or typ is not None
    if typ is None:
        if not isinstance(old, type(new)): return new
        typ = old if isinstance(old,type) else type(old)
    # Do nothing the new type is already an instance of requested type (i.e. same type)
    if typ==NoneType or isinstance(new, typ): return new
    return retain_meta(old, cast(new, typ), as_copy=as_copy)

# %% ../nbs/04_dispatch.ipynb 96
def retain_types(new, old=None, typs=None):
    "Cast each item of `new` to type of matching item in `old` if it's a superclass"
    if not is_listy(new): return retain_type(new, old, typs)
    if typs is not None:
        if isinstance(typs, dict):
            t = first(typs.keys())
            typs = typs[t]
        else: t,typs = typs,None
    else: t = type(old) if old is not None and isinstance(old,type(new)) else type(new)
    return t(L(new, old, typs).map_zip(retain_types, cycled=True))

# %% ../nbs/04_dispatch.ipynb 98
def explode_types(o):
    "Return the type of `o`, potentially in nested dictionaries for thing that are listy"
    if not is_listy(o): return type(o)
    return {type(o): [explode_types(o_) for o_ in o]}
